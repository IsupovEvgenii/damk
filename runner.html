<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>damk: runner</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            background: #fff;
            overflow: hidden;
            font-family: 'Space Grotesk', sans-serif;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        nav {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
        }
        nav a {
            text-decoration: none;
            color: black;
            margin-right: 10px;
            font-size: 16px;
        }
        nav a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
<nav>
    <a href="index.html">about</a>
    <a href="archive.html">archive</a>
    <a href="objects.html">objects</a>
    <a href="runner.html">game</a>
</nav>

<canvas id="game"></canvas>
<script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const groundY = canvas.height * 0.75;
    let score = 0;
    let gameOver = false;

    const player = {
        x: canvas.width * 0.1,
        y: groundY,
        vy: 0,
        width: 70,
        height: 100,
        frame: 0,
        jumping: false
    };

    const gravity = 1;
    const jumpPower = -24;
    let frames = 0;
    const runSprites = [
        new Image(),
        new Image()
    ];
    runSprites[0].src = "assets/runner/run1.png";
    runSprites[1].src = "assets/runner/run2.png";

    const bg = new Image();
    bg.src = "assets/runner/by.png";
    let bgX = 0;

    const cloud = new Image();
    cloud.src = "assets/runner/cloud.png";
    let cloudX = canvas.width;
    let cloudY = groundY * 0.4;

    const obstacleSprites = [
        "ob1.png",
        "ob2.png",
        "ob3.png"
    ].map(name => {
        const img = new Image();
        img.src = `assets/runner/${name}`;
        return img;
    });

    const assetsToLoad = [bg, cloud, ...runSprites, ...obstacleSprites];
    let assetsLoaded = 0;

    assetsToLoad.forEach(img => {
        img.onload = () => {
            assetsLoaded++;
            if (assetsLoaded === assetsToLoad.length) {
                requestAnimationFrame(update);
            }
        };
    });

    let obstacles = [];

    function spawnObstacle() {
        const sprite = obstacleSprites[Math.floor(Math.random() * obstacleSprites.length)];
        obstacles.push({
            x: canvas.width,
            y: groundY,
            sprite: sprite,
            width: 70,
            height: 100,
            counted: false
        });
    }

    function drawBackground() {
        const tileWidth = bg.width;
        bgX -= 2;
        if (bgX <= -tileWidth) bgX = 0;
        ctx.drawImage(bg, bgX, groundY - bg.height);
        ctx.drawImage(bg, bgX + tileWidth, groundY - bg.height);
    }

    function drawCloud() {
        cloudX -= 0.5;
        if (cloudX < -100) {
            cloudX = canvas.width + Math.random() * 300;
            cloudY = groundY * 0.4 + Math.random() * 50;
        }
        ctx.drawImage(cloud, cloudX, cloudY, 100, 60);
    }

    function drawPlayer() {
        ctx.drawImage(runSprites[player.frame], player.x, player.y - player.height, player.width, player.height);
    }

    function drawObstacles() {
        for (let ob of obstacles) {
            ctx.drawImage(ob.sprite, ob.x, ob.y - ob.height, ob.width, ob.height);
        }
    }

    function drawScore() {
        ctx.fillStyle = "#fff";
        ctx.font = "20px sans-serif";
        ctx.fillText(`damks: ${score}`, 20, 60);
    }

    function drawGameOver() {
        ctx.fillStyle = "#000";
        ctx.font = "40px sans-serif";
        ctx.fillText("DAMK", canvas.width / 2 - 60, canvas.height / 2);
        ctx.font = "20px sans-serif";
        ctx.fillText("click to try again", canvas.width / 2 - 70, canvas.height / 2 + 30);
    }

    function update() {
        if (gameOver) {
            drawGameOver();
            return;
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBackground();
        drawCloud();
        drawScore();

        player.vy += gravity;
        player.y += player.vy;
        if (player.y > groundY) {
            player.y = groundY;
            player.vy = 0;
            player.jumping = false;
        }

        drawPlayer();
        if (frames % 20 === 0) player.frame = (player.frame + 1) % 2;

        for (let ob of obstacles) ob.x -= 4;
        drawObstacles();

        while (obstacles.length && obstacles[0].x + obstacles[0].width < 0) obstacles.shift();

        for (let ob of obstacles) {
            const collisionX = player.x + player.width > ob.x && player.x < ob.x + ob.width;
            const collisionY = player.y > ob.y - ob.height;
            const jumpingOver = player.y + player.height < ob.y - 10;

            if (collisionX && collisionY && !(player.vy < 0 && player.y < ob.y)) {
                gameOver = true;
                drawGameOver();
                return;
            }

            if (!ob.counted && ob.x + ob.width < player.x) {
                ob.counted = true;
                score++;
            }
        }

        frames++;
        if (frames % 150 === 0) spawnObstacle();
        requestAnimationFrame(update);
    }

    window.addEventListener("click", () => {
        if (gameOver) {
            score = 0;
            gameOver = false;
            player.y = groundY;
            player.vy = 0;
            obstacles = [];
            frames = 0;
            bgX = 0;
            cloudX = canvas.width;
            requestAnimationFrame(update);
            return;
        }

        if (!player.jumping) {
            player.vy = jumpPower;
            player.jumping = true;
        }
    });
</script>
</body>
</html>
